<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title>stockfish-nnue.wasm</title>
  <meta
    name="viewport"
    content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <link rel="icon" href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+CiAgPGcgc3R5bGU9Im9wYWNpdHk6MTsgZmlsbDpub25lOyBmaWxsLW9wYWNpdHk6MTsgZmlsbC1ydWxlOmV2ZW5vZGQ7IHN0cm9rZTojMDAwMDAwOyBzdHJva2Utd2lkdGg6MS41OyBzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDsgc3Ryb2tlLWRhc2hhcnJheTpub25lOyBzdHJva2Utb3BhY2l0eToxOyI+CiAgICA8cGF0aAogICAgICBkPSJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4IgogICAgICBzdHlsZT0iZmlsbDojMDAwMDAwOyBzdHJva2U6IzAwMDAwMDsiIC8+CiAgICA8cGF0aAogICAgICBkPSJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMCIKICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDsgc3Ryb2tlOiMwMDAwMDA7IiAvPgogICAgPHBhdGgKICAgICAgZD0iTSA5LjUgMjUuNSBBIDAuNSAwLjUgMCAxIDEgOC41LDI1LjUgQSAwLjUgMC41IDAgMSAxIDkuNSAyNS41IHoiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHoiCiAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2LDAuNSwtMC41LDAuODY2LDkuNjkzLC01LjE3MykiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogIgogICAgICBzdHlsZT0iZmlsbDojZmZmZmZmOyBzdHJva2U6bm9uZTsiIC8+CiAgPC9nPgo8L3N2Zz4K"/>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono"/>
  <link rel="stylesheet"
      href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
      integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
      crossorigin="anonymous">
</head>

<!-- CSS -->

<style>
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0;
    font: inherit;
  }

  html,
  body,
  #root {
    height: 100%;
    width: 100%;
  }

  #root {
    font-family: "Roboto Mono";
    font-size: 13px;
  }

  main {
    height: 70%;
    display: flex;
    /* flex-direction: column; */
    padding: 10px;
    width: 600px;
    margin: auto auto;
    margin-top: 100px;
  }

  #central-col {
    display: flex;
    flex-direction: column;
  }

  #misc {
    margin-bottom: 10px;
  }
  
  #click {
    color: rgb(112, 112, 255);
    text-decoration: underline;
    cursor: pointer;
    margin-top: 5px;
  }

  #dead-click {
    text-decoration: underline;
    margin-top: 5px;
  }

  #board1 {
    width: 400px;
    height: 400px;
    margin-bottom: 10px;
  }

  #right-col {
    margin-left: 10px;
    margin-top: 25px;
  }

  #score {
    background-color: #a8a8a8;
    padding: 5px;
    border-radius: 5px;
    border-color: black;
  }

  #output {
    flex: 1 1 auto;
    width: 400px;
    border: 1px solid grey;
    padding: 5px;
    overflow: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 11px;
  }
</style>

<body>
  <div id="root"></div>

  <script src="./lib/stockfish.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mithril@2.0.4/mithril.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
        crossorigin="anonymous"></script>
  <script src="./chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.9.4/chess.min.js"></script>

  <script>
    let board1 = null;
    let stockfish = null;
    let game = new Chess();
    let score = 0;
    let computerSide = "black";

    const NO_EMBEDDED_NNUE = window.location.search.match("no-embedded-nnue");

    const $ = (...args) => document.querySelector(...args);

    const formatMB = (n) => {
      return (n ? (n / 1e6).toPrecision(3) : "?") + "MB";
    };

    const isSupported = () => {
      if (typeof WebAssembly !== "object") return false;
      const source = Uint8Array.from([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 7, 8,
        1, 4, 116, 101, 115, 116, 0, 0, 10, 15, 1, 13, 0, 65, 0, 253, 17, 65, 0,
        253, 17, 253, 186, 1, 11,
      ]);
      if (
        typeof WebAssembly.validate !== "function" ||
        !WebAssembly.validate(source)
      )
        return false;
      if (typeof Atomics !== "object") return false;
      if (typeof SharedArrayBuffer !== "function") return false;
      return true;
    };

    const RequestProgress = ({ attrs: { url, onFinishDownload } }) => {
      let state = "INIT"; // 'LOADING', 'DONE', 'FAILED'
      let loaded = 0;
      let total = 0;

      const oninit = () => {
        state = "LOADING";
        m.request({
          url: url,
          method: "GET",
          responseType: "arraybuffer",
          headers: { Accept: "*/*" },
          config: (xhr) => {
            xhr.onprogress = (e) => {
              // TODO:
              // When gzip compressed, the value of "loaded/total" gets messed up.
              // On Chrome, "loaded" is the value after decompression, but on the other hand,
              // On Firefox, "loaded" is the value before decompression.
              loaded = e.loaded;
              total =
                e.total ||
                Number(
                  e.target.getResponseHeader("x-decompressed-content-length")
                );
              m.redraw();
            };
          },
        }).then(
          (response) => {
            state = "DONE";
            onFinishDownload(response);
          },
          (e) => {
            console.error(e);
            state = "FAILED";
            onFinishDownload(null);
          }
        );
      };

      const view = () => {
        const fraction =
          total == -1 ? `?MB/?MB` : `${formatMB(loaded)}/${formatMB(total)}`;
        return m("span", [
          `${fraction} [${state}] `,
        ]);
      };

      return { oninit, view };
    };

    let stockfish_state = "INIT"; // 'READY', 'FAILED'

    const App = () => {
      // let stockfish = null;
      let output = "";
      let tail_mode = true;

      const sendCommand = () => {
        const command = $("#command").value;
        if (command.length > 0) {
          stockfish.postMessage(command);
        }
      };

      const takeBack = () => {
        console.log("Takeback");   
        game.undo();
        game.undo();
        board1.position(game.fen())
        stockfish_state = "PROCESSING..."; 
        m.redraw();
        setTimeout(function(){ 
          stockfish.postMessage("position " + game.fen());
        }, 100);
      }

      const flip = () => {
        console.log("Flipping");
        if(computerSide === "white") {
          computerSide = "black";
        } else {
          computerSide = "white";
        }
        score = -score;
        // if we flip now it's the computers' turn
        stockfish_state = "THINKING"; 
        m.redraw();
        setTimeout(function() { 
          stockfish.postMessage("position " + game.fen());
          stockfish.postMessage("go");
        }, 100);
      }

      const reset = () => {
        console.log("Resetting position");
        game.reset();
        board1.position(game.fen());
        score = 0;
        m.redraw();
        if(computerSide === "white") {
          stockfish.postMessage("position " + game.fen());
          stockfish.postMessage("go");
        }
      } 

      const parseLine = (line) => {
        if(line.includes("score")) {
          words = line.split(" ");
          for(let i = 0; i < words.length; i++) {
            if(words[i] == "score") {
              score = -parseInt(words[i + 1]);
              break;
            }
          }
        }
        if(!line.includes("bestmove")) {
          return;
        }
        stockfish_state = "READY";
        words = line.split(" ");
        for(let i = 0; i < words.length; i++) {
          if(words[i] === "bestmove") {
            let moveStr = words[i + 1];
            console.log("Making move", moveStr)
            console.log("Prev fen was", game.fen());
            // game.move(moveStr, { sloppy: true });
            let from = moveStr[0] + moveStr[1]
            let to = moveStr[2] + moveStr[3];
            let promotion = 'Q';
            if(computerSide == "black") promotion = 'q';
            console.log(game.turn());
            let move_return = game.move({
              from: from, to: to, promotion: promotion
            });
            console.log(move_return); 
            console.log("FEN is now", game.fen());
            board1.position(game.fen());
            m.redraw();
            break;
          }
        }
      }

      const scrollOutput = () => {
        if (!tail_mode) {
          return;
        }
        $("#output").scrollTo({
          top: $("#output").scrollHeight,
          behavior: "smooth",
        });
      };

      // Make error catchable
      const loadStockfish = async (params) => {
        return await Stockfish(params);
      };

      const onFinishDownload = (data) => {
        if (!data) {
          stockfish_state = "FAILED";
          m.redraw();
          return;
        }

        loadStockfish({ wasmBinary: data })
          .then((_stockfish) => {
            stockfish = _stockfish;
            stockfish_state = "READY";
            stockfish.addMessageListener((line) => {
              parseLine(line);
              output += line + "\n";
              m.redraw();
            });
          })
          .catch((e) => {
            stockfish_state = "FAILED";
            throw e;
          })
          .finally(() => m.redraw());
      };

      const oninit = () => {
        stockfish_state = "LOADING";
      };

      const map = (value, x1, y1, x2, y2) => (value - x1) * (y2 - x2) / (y1 - x1) + x2;

      const min = (x, y) => {
        if(x < y) {
          return x;
        }
        return y;
      }

      const getColor = (score) => {
        let red = 1;
        let green = 1;
        if(score < 0) {
          red = -map(-score, 0, min(-score, 2000), 1, 255);
        } else {
          green = map(score, 0, min(score, 2000), 1, 255);
        }
        return `rgb(${red}, ${green}, 100)`;
      }

      const getSidebar = () => {
        if(stockfish_state === "READY") {
          return m("div#right-col", [
                m("h3#score", { style: { "background-color": "#CBCBCB", "color": getColor(score) } }, `Score is ${score}`),
                m("div#click", { onclick: takeBack }, "Take back"),
                m("div#click", { onclick: reset }, "Reset"),
                m("div#click", { onclick: flip }, "Flip")
          ]);
        } else {
          return m("div#right-col", [
                m("h3#score", { style: { "background-color": "#CBCBCB", "color": getColor(score) } }, `Score is ${score}`),
                m("div#dead-click", "Take back"),
                m("div#dead-click", "Reset"),
                m("div#dead-click", "Flip")
          ]);
        }
      }

      const view = () => {
        return m("main", [
          m("div#central-col", [
            m("div#title", "Dratini v2.0"),
            m("div#board1"),
            m("div#misc", [
              m("div", [
                "- download: ",
                m(RequestProgress, {
                  url: NO_EMBEDDED_NNUE
                    ? "./lib/stockfish-no-embedded-nnue.wasm"
                    : "./lib/stockfish.wasm",
                  onFinishDownload,
                }),
              ]),
              m("div", `- stockfish state: ${stockfish_state}`),
              m("div", `- the engine plays ${computerSide}`)
            ]),
            m("div#output", { onupdate: scrollOutput }, m("pre", output)),
          ]),
          getSidebar()
        ]);
      };

      return { oninit, view };
    };

    m.mount($("#root"), App);

    if (!isSupported()) {
      window.alert(
        "Your browser is not supported. For more information, please take a look at https://github.com/hi-ogawa/Stockfish/wiki."
      );
    }

    const onDrop = (source, target, piece, newPos, oldPos, orientation) => {
      // see if the move is legal
      var move = game.move({
        from: source,
        to: target,
        promotion: 'q' // NOTE: always promote to a queen for example simplicity
      })

      // illegal move
      if (move === null) return 'snapback'
    }

    function onDragStart (source, piece, position, orientation) {
      // do not pick up pieces if the game is over
      if(game.game_over())
        return false

      // only pick up pieces for White
      if((piece.search(/^b/) !== -1 && computerSide === "white")
      || (piece.search(/^w/) !== -1 && computerSide === "black"))
        return false
    }

    const onSnapEnd = () => {
      board1.position(game.fen())
      stockfish_state = "THINKING..."; 
      m.redraw();
      setTimeout(function(){ 
        stockfish.postMessage("position " + game.fen());
        stockfish.postMessage("go");
      }, 100);
    }

    board1 = Chessboard('board1', {
      position: "start",
      draggable: true,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd
    });

  </script>
</body>
